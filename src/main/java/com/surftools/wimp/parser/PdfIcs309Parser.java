/**

The MIT License (MIT)

Copyright (c) 2022, Robert Tykulsker

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


*/

package com.surftools.wimp.parser;

import java.util.ArrayList;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.surftools.utils.pdf.PdfUtils;
import com.surftools.wimp.core.RejectType;
import com.surftools.wimp.message.ExportedMessage;
import com.surftools.wimp.message.Ics309Message;
import com.surftools.wimp.message.Ics309Message.Activity;
import com.surftools.wimp.message.PdfIcs309Message;

/**
 * parser for PDF ICS 309 Communications Log
 *
 * @author bobt
 *
 */
public class PdfIcs309Parser extends AbstractBaseParser {
  private static final Logger logger = LoggerFactory.getLogger(PdfIcs309Parser.class);

  @Override
  public ExportedMessage parse(ExportedMessage message) {
    var from = message.from;
    var mId = message.messageId;

    if (dumpIds.contains(from) || dumpIds.contains(mId)) {
      logger.info("### call: " + mId);
    }

    try {
      // get the first (and hopefully only) PDF ICS-309, extract text, split into lines
      String pdfAttachmentIndices = makePdfAttachmentIndices(message.attachments);
      var indexArray = pdfAttachmentIndices.split(",");
      int first309Index = Integer.valueOf(indexArray[0]);
      var keyList = new ArrayList<String>(message.attachments.keySet());
      var attachmentName = keyList.get(first309Index);
      var bytes = message.attachments.get(attachmentName);
      var pdfUtils = new PdfUtils();
      var text = pdfUtils.getTextFromAllPages(bytes);
      var lines = text.split("\n");

      var pageList = new ArrayList<String>();

      var organization = "";
      var datePrepared = "";
      var timePrepared = "";
      var taskNumber = "";
      var operationalPeriod = "";
      var taskName = "";
      var operatorName = "";
      var stationId = "";
      var incidentName = "";
      var version = "";
      var activities = new ArrayList<Ics309Message.Activity>();

      var areActivitiesCombined = false;

      var lineNumber = 0;
      for (var line : lines) {
        ++lineNumber;

        if (lineNumber == 1) {
          datePrepared = parse(from, mId, line, lineNumber, "DATE PREPARED: ");
          continue;
        }

        if (lineNumber == 2) {
          taskNumber = parse(from, mId, line, lineNumber, "COMMUNICATIONS LOG TASK # ");
          continue;
        }

        if (lineNumber == 3) {
          timePrepared = parse(from, mId, line, lineNumber, "TIME PREPARED: ");
          continue;
        }

        if (lineNumber == 4) {
          var first = "OPERATIONAL PERIOD # ";
          var second = " TASK NAME: ";
          operationalPeriod = parseFirst(from, mId, line, lineNumber, first, second);
          taskName = parseSecond(from, mId, line, lineNumber, second);
          continue;
        }

        if (lineNumber == 5) {
          var first = "RADIO OPERATOR NAME: ";
          var second = " STATION I.D. ";
          operatorName = parseFirst(from, mId, line, lineNumber, first, second);
          stationId = parseSecond(from, mId, line, lineNumber, second);
          continue;
        }

        if (line.startsWith("LOG") || line.startsWith("TIME FROM TO SUBJECT")) {
          continue;
        }

        if (line.startsWith("Page")) {
          var pageLineFields = line.split(" ");
          if (pageLineFields != null && pageLineFields.length >= 2) {
            var page = pageLineFields[1];
            pageList.add(page);
          }
          continue;
        }

        if (lineNumber == lines.length) {
          version = parse(from, mId, line, lineNumber, "309 communications log generated by Winlink Express ");
          continue;
        }

        var activity = makeActivity(from, mId, line, lineNumber);
        if (activity != null) {
          if (activity.dateTimeString() == null) {
            areActivitiesCombined = true;
          } else {
            activities.add(activity);
          }
        }
      }

      activities = consolidateActivities(from, mId, activities);

      var dateTimePrepared = datePrepared + " " + timePrepared;
      var page = String.join(",", pageList);
      var m = new PdfIcs309Message(message, organization, taskNumber, dateTimePrepared, operationalPeriod, taskName,
          operatorName, stationId, incidentName, page, version, activities, pdfAttachmentIndices,
          areActivitiesCombined);

      return m;
    } catch (Exception e) {
      return reject(message, RejectType.PROCESSING_ERROR, e.getMessage());
    }
  }

  private ArrayList<Activity> consolidateActivities(String from, String messageId, ArrayList<Activity> input) {
    var output = new ArrayList<Activity>(input.size());
    var lastDateTime = "";
    var lastFrom = "";
    var lastSubject = "";
    var lastTo = new ArrayList<String>();
    var isFirst = true;

    for (var a : input) {
      if (!a.dateTimeString().equals(lastDateTime) || !a.from().equals(lastFrom) || !a.subject().equals(lastSubject)) {
        var newA = new Activity(lastDateTime, lastFrom, String.join(",", lastTo), lastSubject);

        if (isFirst) {
          isFirst = false; // suppress first control break
        } else {
          output.add(newA);
          lastTo.clear();
        }

        lastDateTime = a.dateTimeString();
        lastFrom = a.from();
        lastSubject = a.subject();
        lastTo.add(a.to());
      } else { // same dateTime, from and subject; just accumulate recipient
        lastTo.add(a.to());
      }
    }

    var newA = new Activity(lastDateTime, lastFrom, String.join(",", lastTo), lastSubject);
    output.add(newA);
    return output;
  }

  private Ics309Message.Activity makeActivity(String from, String messageId, String line, int lineNumber) {
    if (line == null || line.trim().isEmpty()) {
      return null;
    }

    var fields = line.split(" ");
    if (fields == null || fields.length == 0) {
      return null;
    }

    // single field indicates user didn't specify "separate entry for each recipient"
    if (fields.length == 1) {
      return new Ics309Message.Activity(null, null, fields[0], null);
    }

    if (fields.length >= 4) {
      var simpleDateTimeParsing = false;
      if (simpleDateTimeParsing) {
        var dateTime = fields[0] + fields[1];
        var a_from = fields[2];
        var to = fields[3];
        var subject = new ArrayList<String>();
        for (var i = 4; i < fields.length; ++i) {
          subject.add(fields[i]);
        }
        return new Ics309Message.Activity(dateTime, a_from, to, String.join(" ", subject));
      } else {
        // "some people" think that "09 03 24 19:58" is a valid date, time or date/time
        var firstNonNumericIndex = -1;
        for (var i = 0; i < fields.length; ++i) {
          var c = fields[i].charAt(0);
          if (!Character.isDigit(c)) {
            firstNonNumericIndex = i;
            break;
          }
        }

        var dateTimeList = new ArrayList<String>();
        for (var j = 0; j < firstNonNumericIndex; ++j) {
          dateTimeList.add(fields[j]);
        }
        var dateTime = String.join(" ", dateTimeList);
        var a_from = fields[firstNonNumericIndex];
        var to = fields[firstNonNumericIndex + 1];
        var subject = new ArrayList<String>();
        for (var k = firstNonNumericIndex + 2; k < fields.length; ++k) {
          subject.add(fields[k]);
        }
        return new Ics309Message.Activity(dateTime, a_from, to, String.join(" ", subject));
      }
    } else {
      logger
          .warn("from: " + from + ", messageId: " + messageId + ", lineNumber: " + lineNumber //
              + ", could not parse activity from : " + line);
    }

    return null;
  }

  private String parseSecond(String from, String mId, String line, int lineNumber, String second) {
    if (!line.contains(second)) {
      logger
          .warn("from: " + from + ", messageId: " + mId + ", lineNumber: " + lineNumber //
              + " did not find expected text: " + second + " on line: " + line);
      return "";
    }

    return line.substring(line.indexOf(second) + second.length());
  }

  private String parseFirst(String from, String mId, String line, int lineNumber, String first, String second) {
    if (!line.startsWith(first)) {
      logger
          .warn("from: " + from + ", messageId: " + mId + ", lineNumber: " + lineNumber //
              + " did not find expected text: " + first + " on line: " + line);
      return "";
    }

    if (!line.contains(second)) {
      logger
          .warn("from: " + from + ", messageId: " + mId + ", lineNumber: " + lineNumber //
              + " did not find expected text: " + second + " on line: " + line);
      return "";
    }

    return line.substring(first.length(), line.indexOf(second));
  }

  private String parse(String from, String messageId, String line, int lineNumber, String expected) {
    if (line.startsWith(expected)) {
      return line.substring(expected.length());
    } else {
      logger
          .warn("from: " + from + ", messageId: " + messageId + ", lineNumber: " + lineNumber //
              + " did not find expected text: " + expected + " on line: " + lineNumber);
      return "";
    }
  }

  /**
   * find the indices of all the attachments that are ICS-309 pdfs. Hopefully only one!
   *
   * @param attachments
   * @return
   */
  private String makePdfAttachmentIndices(Map<String, byte[]> attachments) {
    var indexList = new ArrayList<String>();
    var keyList = new ArrayList<String>(attachments.keySet());
    for (var i = 0; i < attachments.size(); ++i) {
      var attachmentName = keyList.get(i);
      var bytes = attachments.get(attachmentName);
      if (isAttachmentPdfIcs309(bytes)) {
        indexList.add(String.valueOf(i));
      }
    }
    return String.join(",", indexList);
  }

  public static boolean isPdfIcs309(ExportedMessage message) {
    var keyList = new ArrayList<String>(message.attachments.keySet());
    for (var i = 0; i < message.attachments.size(); ++i) {
      var attachmentName = keyList.get(i);
      var bytes = message.attachments.get(attachmentName);
      var isPdfIcs309 = isAttachmentPdfIcs309(bytes);
      if (isPdfIcs309) {
        return true;
      }
    }

    return false;
  }

  private static boolean isAttachmentPdfIcs309(byte[] bytes) {
    var pdfUtils = new PdfUtils();

    var isPdf = pdfUtils.isPdf(bytes);
    if (!isPdf) {
      return false;
    }

    var text = pdfUtils.getTextFromAllPages(bytes);
    if (text == null) {
      return false;
    }

    var lines = text.split("\n");
    if (lines == null || lines.length == 0) {
      return false;
    }

    var lastLine = lines[lines.length - 1];
    if (lastLine.contains("309 communications log generated by Winlink Express")) {
      return true;
    }

    return false;
  }

}
